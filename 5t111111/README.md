Title: Crystal プログラムのビルドとデプロイ
Author: Hirofumi Wakasugi
Twitter: @5t111111
# はじめに

Crystal 本を読んでいただきありがとうございます。この本を手に取ったということは、あなたはきっと Crystal に興味を持ち、そしてプログラミング言語として魅力を感じているのだと思います。

では、あなたにとって、Crystal の魅力とはいったい何でしょうか？

- Ruby と似たシンタックスでプログラミングができる
- 静的な型チェックがある
- 高速である

おそらく、こういった点を Crystal の魅力と感じている方が多いのではないかと思います。そして、これらは確かにアプリケーションを開発する上で非常に重要な要素であり、Crystal が提供してくれる魅力に間違いないでしょう。しかし、ここでは、Crystal のもう1つの重要な特徴である

- ネイティブコードにコンパイルされ、ワンバイナリで配布できる

という点に注目したいと思います。今日の多くの開発者にとって、このことも Crystal を選択する大きな理由になると考えるからです。

アプリケーションをデプロイするとき、その実行環境の構築は頭を悩ませるものになりがちです。例えば Ruby 製のアプリケーションをデプロイするときのことを考えてみましょう。Ruby プログラムを動かすためには、当然、稼働環境に Ruby インタプリタがインストールされている必要があります。また、そのときには Ruby 自体のバージョンや依存ライブラリ (gem) の構成についても気を配る必要があります。

もし、プログラムの実行ファイルだけを稼働環境にコピーすればそれだけでアプリケーションが動いたらどれだけ楽でしょうか。Crystal がワンバイナリで配布できるということは、このようなアプリケーションのデプロイの悩みを解決する1つの解決策となるでしょう。

これから、Crystal アプリケーションの概要やビルドのしかたなどの基本的なところから、クロスコンパイルやライブラリのリンクなどの話も交えつつ、完成したバイナリを配布するところまでを通して見ていこうと思います。

尚、本章で利用した Crystal は、執筆時点の最新バージョンである 0.21.1 です。異なるバージョンの Crystal ではサンプルのコードなどが動作しない可能性があることをご了承ください。

# Crystal プログラムの概要

## プログラムの実行のしかた

この本を手に取った方は、おそらくすでに一度は Crystal プログラムを動かしたことがある人が多いかと思いますが、はじめての人のために、基本的な Crystal プログラムの実行方法の紹介から順番に進めていきます。

**hello_world.cr**

```crystal
puts "Hello, world!"
```

これは、説明するまでもない「Hello World」プログラムで、Crystal で書かれたプログラムとしては最も単純なものの1つです。このプログラムを実行するためには、以下のように `crystal run` コマンドを使います (crystal がインストールされている必要があります) 。

```shell
$ crystal run hello_world.cr
```

これを実行すると、画面には以下のように表示されます。


```shell
Hello, world!
```

きっとこれはみなさんの期待通りの動作だと思います。このように `crystal run` でプログラムを実行したとき、結果だけを見ると、例えば Ruby などでスクリプトを実行したときと特に違いを感じることはほとんどないかと思います。

しかし、Crystal はコンパイラ言語であるため、こうしてプログラムが実行されるときも、その背後ではソースコードのコンパイルとリンク、つまりプログラムのビルドが行われています。

※厳密に言うと、スクリプト言語やライトウェイト言語はコンパイルされない、というのは正しくありません。実際には最適化を目的として中間表現へコンパイルするものなどもあります。例えば Ruby ではコードは YARV という仮想マシン処理系の命令セットにコンパイルされます。ただ、ここでは話を簡単にするために Crystal のように明示的にコンパイルすることが一般的な言語を称してコンパイラ言語と呼んでいます。

## プログラムのビルド

Crystal プログラムのビルドも簡単です。ビルドするには `crystal build` コマンドを使います。先ほどの「Hello World」プログラムをビルドしてみましょう。

```shell
$ crystal build hello_world.cr
```

これを実行すると、`crystal run` のときとは異なってまだこの時点ではプログラムが実行されていないため、画面に「Hello, world!」の出力はされません。その代わりに、同じディレクトリに `hello_world` というファイルができていることが確認できるでしょう。

この `hello_world` こそが「Hello World」プログラムの実行ファイルで、一般的には「バイナリ」と呼ばれるものです。

バイナリはその名前の通り2進数で記述されたデータのことを指し、主にコンピューターが直接解釈可能な機械語のプログラムを意味します。これはつまり、この実行ファイルが冒頭に挙げた「ネイティブコード」であることを示しています。

※ただし、バイナリというものが常に実行ファイルのことを示すわけではありません。これから本文中でも、実行ファイルに限らず機械語のプログラムのことをバイナリと総称することがあります。例えば後述する「オブジェクトファイル」などはネイティブコードのバイナリですが、実行ファイルではありません。

`file` コマンドなどでファイルの情報を見てみましょう。具体的な内容は処理系に依存しますが、多くの場合 `executable` などの表記があり実行ファイルであることが確認できると思います。例えば、以下は macOS 上でビルドしたバイナリの情報です。

```shell
$ file hello_world
hello_world: Mach-O 64-bit executable x86_64
```

では、このバイナリを実行してみましょう。バイナリのパスを指定して実行します。カレントディレクトリにバイナリがあれば実行方法は以下となります。

```shell
./hello_world
```

すると、画面には以下のように表示されます。

```shell
Hello, world!
```

これも期待通りでしょう。

ただ、ここでは、もう少しその裏側で起こっていることにも目を向けてみます。Crystal のプログラムをビルドするときには、最終的な生成物であるバイナリを構成する中間表現がいくつも生成され、実際にそれらを確認することもできます。

## プログラムを構成する要素

Crystal プログラムをビルドすると、デフォルトではホームディレクトリの `.cache` ディレクトリに以下に `crystal` というディレクトリが作られ、そこに上記の中間表現のファイルが格納されています。少しその中を覗いてみましょう。

```
$ ls $HOME/.cache/crystal
```

多くのファイルやディレクトリのリストが出力されたことと思います。今回はその中でも、先ほどの「Hello World」プログラムに直接関連するファイルを確認してみます。

「Hello World」プログラムをどこでビルドしたかに依存しますが、出力されたリストの中から、ビルドしたディレクトリのパスを含む名前のディレクトリを探してみてください。パスはハイフンで区切られています。例えば macOS のホームディレクトリに `hello_world` というディレクトリを用意してそこでビルドした場合、`Users-username-hello_world.cr` というディレクトリとなります。

そのディレクトリの中を見てみると、`.bc` と `.o` というファイルが大量に作られているのがわかると思います。これらはそれぞれ、

- `.bc` : LLVM ビットコード
- `.o` : オブジェクトファイル

であり、どちらもバイナリ、つまり機械語で記述されたデータです。

LLVM に関してはあまり詳細には踏み込まず概要だけ簡単に説明しますが、LLVM ビットコードは Crystal プログラムがコンパイルされた LLVM のための中間表現のバイナリデータであり LLVM のアセンブリです。`llvm-dis` というコマンドを使うことで、これを LLVM IR というテキスト形式の命令セット (`.ll`) に変換して内容を参照することも可能です。もちろん、逆に LLVM IR からアセンブリを生成することも可能で、それには `llvm-as` コマンドを使います。

一方、オブジェクトファイルはプログラムがコンパイルされて生成される成果物と呼ぶべきもので、上記 LLVM ビットコードがターゲットのアーキテクチャ向けにコンパイルされたもの、すなわち「ネイティブコード」です。最終的に生成された実行ファイルのバイナリは、これらのオブジェクトファイルがリンカによってリンクされたものになります。

# ネイティブコード

これまで何度も、「Crystal はネイティブコードにコンパイルされる」と書いてきました。そして、ネイティブコードはバイナリでありコンピューターが解釈できる機械語であることも同時に述べました。しかし、例えば他の (ネイティブコードにコンパイルされない) プログラミング言語と比較して一体何が違うのでしょうか。

ここからは、他のプログラミング言語も例に挙げながら、ネイティブコードにコンパイルされることがどういうことかを見ていきたいと思います。

## Write once, run anywhere

「Write once, run anywhere」という言葉を聞いたことがある人は多いと思います。これは、当時 Java を開発していた Sun Microsystems がそのクロスプラットフォーム性を表現するために作ったスローガンです。実際に Java は1つのプログラムを様々なプラットフォーム上で動かすことができます。

この辺りの話はすでにご存知の人の方が多いと思いますし、しばらく Crystal から離れた話になってしまうのですが、ネイティブコードのプログラムの説明の前に比較対象として見ておくとよりわかりやすいと思うので、しばらくこういったクロスプラットフォームのプログラミング言語がどのように動いているかを見ていきます。

例にあげた Java では、プログラムは JVM (Java Virtual Machine) という仮想マシン上で動作します。もう少し具体的に言うと、Java で記述されたプログラムのコードがコンパイルされると、JVM が解釈可能な命令セット (Java バイトコード) に変換され、それが JVM 上で実行される仕組みになっています。つまり、どんなプラットフォームであれ、そこに環境の違いを吸収してくれる JVM さえあれば同じ Java プログラムを動かすことが原理的には可能だということです。

では、冒頭でも少し触れましたが、シンタックスの類似性から Crystal と比較されることの多い Ruby はどうでしょうか。Ruby も処理系さえ用意されていればどの環境でも同じようにプログラムが動きますよね。他にも Python や PHP といったライトウェイト言語は同様に処理系を用意することでプログラムの内容はそのままにマルチプラットフォームで動かすことが可能です。

このように、これらのプログラミング言語はそれぞれの処理系を用意することでクロスプラットフォーム/マルチプラットフォームを実現しています。素直に考えると、こういったアプローチは良いことばかりのように感じられます。一方でこれから説明するネイティブコードにコンパイルされるプログラミング言語は、環境が違うと動作しないため不便なものに思えます。

## ネイティブコードのプログラムとそのメリット

ではネイティブコードのプログラムには一体どんな利点があるのでしょうか。

前項で、マルチプラットフォームのプログラミング言語は、仮想マシンなどの処理系を介することで、同じコードを異なる環境で動かすことができると述べました。これは裏を返せば、その処理系がないとプログラムを動かすことができないということでもあります。この章の冒頭でも買いた通り、その実行環境の構築はアプリケーションのデプロイで頭を悩ませるポイントであることを実感している方も多いのではないでしょうか。

一方、Crystal のようにネイティブコード、つまり機械語のバイナリを生成することができるプログラミング言語は、そのターゲットとなる OS やアーキテクチャ向けにビルドされていれば、特別な処理系をインストールすることなくプログラムを動かすことができます。

ネイティブコードのもう1つの大きなメリットは速度です。画一的に言えることではありませんが、やはり中間表現にコンパイルされて独自の処理系で動作するプログラムは、一般的にはネイティブコードのプログラムよりオーバーヘッドがあり実行速度が遅くなりがちです。

このように、ネイティブコードのプログラムには

- 特定の処理系を用意しなくても実行できる
- 一般的に実行速度が高速である

というメリットがあります。

ネイティブコードにコンパイルされるプログラムの代表的なものといえば C 言語や C++ をまず挙げられますが、特に最近は新しいプログラミング言語でも人気のあるものが増えてきていて、Go 言語、Rust、Swift などがネイティブコードにコンパイルされるプログラミング言語です。こういった潮流の背景には、LLVM などによってコンパイラを開発しやすくなったことや、Docker といったインフラの新技術とも相性がよかったことなどがあると考えています。

# Crystal プログラムのデプロイ

ここまで、ごく基本的な Crystal プログラムの実行/ビルドの方法やネイティブコードのプログラムの概要を見てきましたが、ここからはもう少し実践的に、実際の Crystal プログラムのデプロイ方法について書いていきます。

## Release ビルド

まず、Crystal プログラムを Release 版としてビルドする方法について紹介します。先ほど、`crystal build` コマンドによって Crystal のプログラムをビルドすることができると書きました。しかし、実はそれだけでは最適化されたバイナリを生成することができません。最適化のためには `--release` というフラグを使います。例えば先述の「Hello World」プログラムに対して release ビルドを行い最適化するには以下のようにします。

```shell
$ crystal build hello_world.cr --release
```

こうすると、最適化されたバイナリが生成されます。したがって、開発中は `--release` なしで実行やビルドを行い、実際にプログラムをデプロイする際には `--release` フラグによって最適化されたバイナリを生成するようにすることが基本となります。

## ビルドする環境と同一の OS/アーキテクチャ環境へのデプロイ

例えば、Crystal コンパイラをインストールし、プログラムを開発する環境が 64 ビット x86 アーキテクチャの Linux だとしましょう。そして、実際にプログラムを動作させたい環境も同じく 64 ビット x86 アーキテクチャの Linux だとします。

このように、ターゲットが Crystal プログラムをビルドするプラットフォームと同じである場合、プログラムのデプロイは極めて簡単です。`crystal build` によって生成されたバイナリは実行環境と同一の環境をターゲットとしたネイティブコードにコンパイルされていますので、特に特別な環境構築を行うことなしにそのまま実行することができます。Crystal コンパイラをインストールする必要もありません。つまり、単純にビルドしたバイナリを実行環境にコピーすればそれだけでデプロイが可能だということです。先ほどネイティブコードの利点として書いた通り、このワンバイナリでのプログラムのデプロイの容易は Crystal の魅力の1つと言えるでしょう。

より具体的なバイナリのデプロイ方法としては、

- CI に組み込んで自動的に最新バージョンを配布する
- GitHub の Release 機能などを使ってコードベースと同様に管理し実行環境でダウンロードする
- scp などで直接コピーする

などが挙げられるかと思います。ただ、結局はコピーすればいいだけなので、それが実現できればどんなやり方でも構いません。このように、デプロイ方法に選択の幅が広がるのもバイナリで配布できることのメリットと言えます。

## ビルドする環境と異なる OS/アーキテクチャ環境へのデプロイ

ビルド環境と同一 OS/アーキテクチャの環境へのデプロイは簡単だと書きました。では、これが異なっている場合はどうでしょうか。例えば、Crystal コンパイラをインストールした開発環境は macOS で、プログラムを実行したいターゲットは Linux である場合などです。

### クロスコンパイル

Crystal はクロスコンパイルをサポートしています。クロスコンパイルというのは

- ビルドする環境とは異なるプラットフォーム向けにコンパイルする

機能になります。クロスコンパイルによって、macOS 上で Linux 向けのバイナリをコンパイルすることも可能になります。

ただし、現状においてクロスコンパイルはオプションとして用意されてはいますが、実際にこれがあればターゲットに合わせた個別のビルド環境は不要、とまで言える段階ではありません。Crystal の作者も同一の OS/アーキテクチャ上でビルドすることを推奨しています。これからクロスコンパイルの方法を見ていきますが、その中でまだ実用には少し難しい理由もわかると思います。

Crystal でクロスコンパイルを行うには、`crystal build` コマンドに `--cross-compile` フラグを与えます。ただ、これだけではどのターゲット向けにコンパイルすればいいかがわからないので、同時に `--target` フラグによってコンパイルのターゲットを指定する必要があります。`--target` フラグに指定する値は、ターゲット上で `llvm-config --host-target` を実行することで得られます。例えば 64 ビット x86 アーキテクチャの Linux マシンであれば、その値は「x86_64-pc-linux-gnu」などとなりますし、macOS であれば「x86_64-apple-darwinXX.X.X」のようになります。

では、上記した Linux マシンをターゲットの例とした場合のクロスコンパイルの具体的なコマンドを見てみます。`--cross-compile` フラグと、「x86_64-pc-linux-gnu」を `--target` フラグに指定するので以下のようになります。

```shell
$ crystal build hello_world.cr --cross-compile --target "x86_64-pc-linux-gnu"
```

上記を実行し正常にコンパイルが完了すると、画面上に

```text
cc hello_world.o -o hello_world  -rdynamic  -lpcre -lgc -lpthread /usr/local/Cellar/crystal-lang/0.21.1/src/ext/libcrystal.a -levent -lrt -ldl -L/usr/lib -L/usr/local/lib
```

といった内容が出力されたことでしょう。これは「実際にプログラムを実行したい環境」、つまりターゲットのマシン上で実行するためのコマンドです。したがって、これは後ほど利用するものなのでコピーするなどして控えておきます。今クロスコンパイルを実行した環境で実行するのではないことに注意してください。

クロスコンパイルを実行すると、オブジェクトファイル (`.o`) が生成されます。これはネイティブコードのバイナリですが、実行ファイルではありません。つまり、実行ファイルや Crystal から直接利用できるライブラリを生成するには、リンカを使ってこのオブジェクトファイルを他の依存ライブラリとリンクして実行ファイルを生成する必要があります。その際にターゲットのマシン上でリンクするために実行するコマンドが、先ほど画面に表示されたコマンドというわけです。

念のために、生成されたオブジェクトファイルの情報を見てみます。

```shell
$ file hello_world.o
hello_world.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped
```

確かに ELF 形式 (多くの Linux プラットフォームでの標準的なバイナリの形式) となっており、Linux 向けにコンパイルされていることが確認できました。

### ターゲット上でのバイナリの生成

それでは、ターゲットのマシン上で実際にコマンドを実行し実行ファイルのバイナリを生成してみましょう。

まず、先ほど出力されたリンクのためのコマンドをもう一度確認してみます。

```text
cc hello_world.o -o hello_world  -rdynamic  -lpcre -lgc -lpthread /usr/local/Cellar/crystal-lang/0.21.1/src/ext/libcrystal.a -levent -lrt -ldl -L/usr/lib -L/usr/local/lib
```

生成された `hello_world.o` が要求されているのは当然ですね。その他にリンクするライブラリが指定されていますが、特に `/usr/local/Cellar/crystal-lang/0.21.1/src/ext/libcrystal.a` というものに注目してください。今回例として利用した macOS のビルド環境では、Homebrew でインストールした Crystal コンパイラを利用しました。その際に一緒に提供されている静的リンクのためのライブラリがこの `libcrystal.a` なのですが、出力されている内容では macOS 上でのパスがそのまま表示されてしまっています。また、これは macOS をターゲットとしてコンパイルされたファイルであるため、Linux 用にコンパイルされたものを利用し、ターゲットの環境で実行するときにはそのパスを指定する必要があります。

では、`hello_world.o` を scp などの何らかの方法でターゲットの OS 上にコピーします。

そして、ターゲットのマシン用にコンパイルされた `libcrystal.a` を用意します。これは、macOS および Linux 版であれば、自分でコンパイルしなくても Crystal の Releases ページからダウンロードできるアーカイブに含まれています。

https://github.com/crystal-lang/crystal/releases

上記より該当のターゲットのアーカイブをダウンロードし、`src/ext/` に含まれる `libcrystal.a` を同様にターゲットマシン上にコピーしてください。

コピーしたら、先ほどのリンクコマンドを実行します。`libcrystal.a` のパスを修正することを忘れないようにしてください。

```shell
$ cc hello_world.o -o hello_world  -rdynamic  -lpcre -lgc -lpthread libcrystal.a -levent -lrt -ldl -L/usr/lib -L/usr/local/lib
```

リンクするための `pcre` や `gc` のライブラリがないと表示された場合には、ターゲットマシンにそれらのライブラリをインストールする必要があります。Linux であれば、ほとんどの場合はディストリビューションが提供するパッケージからインストールできます。

すべて必要なものが揃っていれば、実行ファイル `hello_world` のバイナリが生成され、もちろん実行することが可能です。

### クロスコンパイルの課題

これまで見てきたように、Crystal でクロスコンパイルを行うことは可能ですが、

- 最終的なバイナリの生成はターゲットマシン上で行う必要がある
- 依存ライブラリのパッケージインストールやコピーが必要になる

などを自分で行う必要があり、決して簡単/便利に使うことができるものではありません。本項の最初に、まだ実用するには難しい点があると書きましたが、こういったことがその理由です。

例えば Go 言語では、クロスコンパイルが非常に簡単に行えるようになっているのですが、Crystal はまだそこまでの段階には至っていません。これは Go 言語が少しずつ時間をかけて外部のライブラリに依存しないように実装を改善してきたり、クロスコンパイルのためのツールチェインを発展させてきたことによります。Crystal はそれと比較するとまだ非常に若いプログラミング言語なので、将来的にはよりクロスコンパイルが改善されることに期待したいです。

## スタティックリンク

バイナリの生成におけるもう1つのトピックとして、スタティックリンクというものがあります。クロスコンパイルの節でも見てきたように、Crystal は外部ライブラリへの依存があります。通常のビルドの場合は、Crystal プログラムは依存ライブラリとダイナミックリンクされ、実行時にそれらを共有ライブラリとして利用します。これは、アーキテクチャが同じであったとしても、依存する共有ライブラリが存在しない場合には実行できないことを意味しています。例えば Linux のディストリビューションの違いやパッケージの不足などにより実行ができないケースがあります。

その代表的なものは libc です。ターゲットのマシン上にマッチする glibc がある場合には問題になりませんが、そうでない場合には実行することができません。例えば、非常に軽量な Linux ディトリビューションとして注目を集めている Alpine Linux にはデフォルトでは glibc が含まれていません。

こういった問題を解決する1つの方法がこのスタティックリンクで、バイナリに依存ライブラリを埋め込むことで、実行時にダイナミックリンクしなくてもプログラムを単独で動作可能にするものです。

Crystal では `crystal build` コマンドに `--link-flags="-static"` というフラグを設定することでスタティックリンクしたバイナリを生成することができます。

しかし、スタティックリンクにも課題が多くあります。1つはそもそも glibc をスタティックリンクすることが非常に困難であるということです。ここでは詳細には触れませんが、Crystal が通常利用するライブラリの1つである NSS ライブラリは通常は完全にスタティックリンクすることができません。また、バイナリにライブラリをスタティックリンクすることはソフトウェアの複製と解釈され、ライセンスに適合するために多大な配慮が要求されることもあります。

したがって、Crystal プログラムのビルドにおいて、残念ながら現状ではスタティックリンクは現実的な手法とは言えません。ただ、 glibc 以外にも musl のようなスタティックリンク志向の libc 実装もあり、Crystal でも musl をサポートしたコンパイラへの取り組みが進められています。ですので、スタティックリンクに関しても将来的にはより環境が整備され使いやすくなると考えられます。

# まとめ

この章では、Crystal プログラムがネイティブコードにコンパイルされることで、バイナリをそのままデプロイできること、そしてその利点や注意点を見てきました。

クロスコンパイルやスタティックリンクなどでまだまだ課題は残っていますが、現在は Docker などを利用してターゲットの OS/アーキテクチャと合わせたビルド専用の環境を用意することも難しくないため、バイナリで手軽に配布できることで得られる利点は非常に大きいと考えています。まずはこのデプロイの容易さを活用しやすい CLI ツールの開発などを通して、その魅力を感じていただければ幸いです。
